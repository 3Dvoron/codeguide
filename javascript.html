<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <title>Стиль кода Академии HTML</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@htmlacademy_ru">
    <meta name="twitter:image" content="https://htmlacademy.github.io/codeguide/img/og.png">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://htmlacademy.github.io/codeguide/">
    <meta property="og:title" itemprop="name" content="Стиль кода Академии HTML">
    <meta property="og:image" itemprop="image" content="https://htmlacademy.github.io/codeguide/img/og.png">

    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/prism.css">
    <link rel="stylesheet" href="css/style.css">

    <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-29640059-7','auto');ga('send','pageview');</script>
  </head>
  <body>

    <header>
      <a href="https://htmlacademy.ru" target="_blank">
        <img class="logo" src="img/bane.svg" width="300" height="300" alt="HTML Academy" title="HTML Academy">
      </a>
      <h1>Стиль кода Академии HTML</h1>
      <p><a href="https://github.com/htmlacademy/codeguide">github.com/htmlacademy/codeguide</a></p>
    </header>

    <main>
      <!-- <section class="chapter">
        <h2>Оглавление</h2>
        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4>JS</h4>
            <ul>
              <li><a href="#html-syntax">Синтаксис</a></li>
            </ul>
          </div>
        </article>
      </section> -->

      <section class="chapter">
        <h2>Синтаксис</h2>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Отступы, пробелы и переносы</h4>
            <ul>
              Для правильного форматирования используйте файл .editorconfig в вашем редакторе.

              <li>Для отступов используются два пробела. Знак табуляции не используется. При переносах в продолжении строки используется четыре пробела.</li>

              <li>Запрещено одновременное использование табов и пробелов для отступов.</li>

              <li>Выражения должны заканчиваться точками с запятой.</li>

              <li>Внутри строки не используется более одного пробела.</li>

              <li>Открывающие скобки блоков кода находятся на одной строке с оператором, которых их использует
                <pre class="language-js"><code>- if (condition)
- {
-   // code
- }

+ if (condition) {
+   // code
+ }</code></pre>
                </li>

              <li>В однострочных блоках кода, код отделен от открывающей и закрывающей скобки пробелом</li>

              <li>В однострочных массивах скобки не отделяются пробелами, первое значение идет непосредственно после закрывающей скобки, а закрывающая скобка идет непосредственно после последнего значения массива</li>

              <li>После запятой всегда должен ставиться пробел, если запятая не в конце строки</li>

              <li>Запрещено переносить запятую на новую строку при создании множественных переменных через один var, при объявлении массивов и объектов. Запрещено использовать запятую в конце списков, объектов или наоборов параметров функции.</li>

              <li>Файл должен заканчиваться пустой строкой</li>

              <li>Строка не должна заканчиваться пробелами</li>

              <li>В однострочных объектах и при деструктуризации фигурные скобки отбиваются пробелами с двух сторон</li>

              <li>В коде не используются совместно табы и пробелы</li>

              <li>Блоки кода отделяются друг от друга не более чем двумя пустыми строками</li>

              <li>В качестве символа строки используется стандартный символ, который используется в системе</li>

              <li>При объявлении вычисляемых ключей в объектах с помощью синтаксиса ES2016 в квадратных скобках не используются пробелы</li>

              <li>Оператор вызова функции () не отделяется круглыми скобками от названия функции</li>

              <li>В объектах после объявления ключа не ставится пробел. После двоеточия, которое отделяет в объектах ключ от значения может стоять только один пробел, выравнивать несколько значений при объявлении многострочного объекта запрещено</li>

              <li>Ключевые слова отделяются пробелами. Правило касается всех блоков, которые не оговорены отдельно в других правилах. В частности ключевые слова должны отделяться пробелами для условных операторов, циклов, операторов множественного выбора, блоков try..catch, объявлений классов и т. д.</li>

              <li>В блоках кода первая и последняя строка не должны быть пустыми (код не отбивается от начала блока кода)</li>

              <li>После двоеточий и точек с запятым ставятся пробелы. Перед ними — не ставятся.</li>

              <li>Перед скобками начинающими новый блок кода должен ставиться пробел.</li>

              <li>при объявлении анонимных функций, скобки с параметрами ставятся непосредственно после ключевого слова function. Если функция именована, перед названием ставится пробел, после — нет.</li>

              <li>В комментариях текст отбивается пробелом от начала комментария.</li>

              <li>При создании генераторов, звездочка идет сразу после ключевого слова function без пробелов</li>

              <li>В spread-операторе точки не отделяются от названия коллекции</li>

              <li>Звездочка после ключевого слова yield не отбивается пробелом. После звездочки проблел ставится всегда.</li>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Строки</h4>
            <ul>
              <li>В строках, объявленных с помощью одинарных и двойных кавычек запрещено использовать переносы.</li>

              <li>В строках запрещено указывать код спецсимволов в восьмеричной системе счисления <pre class="language-js"><code>- var foo = "Copyright \251";
+ var foo = "Copyright \u00A9";</code></pre></li>

              <li>При создании объектов через литералы свойства должны объявляться в едином стиле: или без кавычек или с ними.</li>

              <li>В строках используются одинарные кавычки. Разрешено использовать строковые шаблоны. Если позволяет поддержка, предпочтение отдается строковым шаблонам.</li>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Числа</h4>
            <ul>
              <li>В числах запрещено опускать ноль в дробной и целой части.</li>

              <li>Запрещено использовать ведущий ноль при создании чисел, поскольку это приводит к созданию числа в восьмеричной системе счисления.</li>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Литералы</h4>
            <ul>
              <li>Массивы должны создаваться через литерал массива, а не через конструктор. Допустимое исключение — создание массива определенной длины.</li>

              <li>Объекты должны создаваться через литерал объекта, а не через конструктор.</li>

              <h5>Объекты</h5>
              <li>При создании объектов запрещено дублирование ключей.</li>

              <li>При описании функций запрещено дублировать названия параметров.</li>

              <li>В операторе <code>switch</code> запрещено дублировать условия (case)</li>

              <h5>Массивы</h5>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Операторы</h4>
            <ul>
              <li>В бинарных и тернарных операторах операнды и символы оператора отделяются пробелами.</li>

              <li>Унарные операторы не отделяются от операнда пробелом. Исключения составляют операторы, состоящие из слов, а не символов, например оператор typeof.</li>
            </ul>
          </div>
        </article>

      </section>

      <section class="chapter">
        <h2>Именование</h2>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <ul>
              <li>Запрещено объявлять переменные, имена которых совпадают с именами используемых в коде лейблов</li>

              <li>Все переменные должны быть названы в верблюжьем регистре. Исключения составляют константы которые должны именоваться прописными буквами в змеином регистре.</li>

              <li>Запрещено использовать имена переменных, которые используются во внешних областях видимости.</li>

              <li>Запрещено называть переменные и свойства ключевыми словами JS</li>

              <li>Запрещено использовать переменные, не объявленные ранее. При использовании переменной, объявленной в другом модуле в глобальной области видимости нужно обращаться к ней как в свойству объекта <code>window/global</code>.</li>

              <li>Запрещено объявлять переменные без значения.</li>

              <li>Запрещено напрямую обращаться к значению <code>undefined</code>. Для проверки типа рекомендуется использовать <code>typeof</code>. Для прямого сравнения с <code>undefined</code> можно использовать конструкцию <code>void 0</code>.</li>

              <li>С заглавной буквы называются только функции-конструкторы.</li>
            </ul>
          </div>
        </article>

      </section>

      <section class="chapter">
        <h2>Предотвращение ошибок</h2>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <ul>
              <li>Все точки с запятой должны быть проставлены явно, не стоит рассчитывать на автоматическую расстановку точек с запятой ASI.</li>

              <li>Не рекомендуется использовать указатель Unicode BOM в коде, потому что код должен быть сохранен не в кодировке UTF-16, а в кодировке UTF-8, в которой нет указателя порядка бит.</li>

              <li>Обязательно используются блоки кода даже если в выражении содержится одна строчка</li>

              <li>В коде нет пустых блоков кода</li>

              <li>Код работает в строгом режиме: в начале всех файлов явно прописана директива <code>use strict</code>.</li>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Условные операторы</h4>
            <ul>
              <li>Запрещена "проверка Йоды" — в условных операторах в блоке условия при сравнении переменной или свойства со значением сначала идет переменная или свойство объекта и только потом значения, а не наоброт. <pre class="language-js"><code>- if (1 === myValue) {}
+ if (myValue === 1) {}</code></pre></li>

              <li>При сравнении двух значений используется оператор строгого сравнения вместо оператора нестрогого сравнения</li>

              <li>В условных операторах не используется оператор присвоения</li>

              <li>В условтях не используется небезопасное отрицание, например использование ! в in или instanceof без скобок.</li>

              <li>Запрещено сравнение с NaN. Для проверки, является результат операции числовым, нужно использовать <code>isNaN</code>.</li>

              <li>Запрещено использовать case без break или return в блоках switch.</li>

              <li>Не используются вложенные тернарные операторы.</li>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Функции</h4>
            <ul>
              <li>Если в функции используется ветвление, в котором есть возврат значения (<code>return</code>), <code>return</code> должен быть добавлен и в остальных ветках. Это правило предотвращает создание функций, при использовании которых непонятно, вернут ли они какое-то значение. <pre class="language-js"><code>- var do = function() {
-   if (cond) {
-     return 1;
-   } else {
-     // Проблема заключается в том, что
-     // в первой ветке условия возвращается
-     // единица, а в альтернативной нет никакого
-     // возврата и при вызове функции неизвестно
-     // будет ли из нее возвращего какое-то значение.
-     doSomethingElse();
-   }
- }
+
+ var do = function() {
+   if (cond) {
+     return 1;
+   } else {
+     return 2;
+   }
+ }</code></pre></li>

              <li>В return не используется оператор присваивания.</li>

              <li>В стрелочных функциях всегда используются скобки для параметров, даже если параметр один</li>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Операторы</h4>
            <ul>
              <li>В конструкторе классов-наследников  обязательно вызывается super()</li>

              <li>В конструкторе нет обращения к this до того, как будет вызван super()</li>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Объявление переменных и функций</h4>
            <ul>
              <li>При объявлении переменных предпочтение отдается ключевым словам let и const. Переменные объявляются через var только при наличии проблем с поддержкой кода.</li>

              <li>Запрещено переопределять с помощью ключевого слова ранее созданные переменные</li>

              <li>Запрещено использовать множественное объявление через одно ключевое слово. Для каждой переменной используется отдельный <code>var</code>, <code>let</code> или <code>const</code>. Это правило облегчает отладку, поскольку создание нескольких переменных через запятую трактуются движком как одна операция, что означает, что невозможно поставить отладчик на создание одной из переменных. <pre class="language-js"><code>- var a = 1, b = 2;
-
+ var a = 1;
+ var b = 2;
            </code></pre></li>
            </ul>

            <h5 id="">Объявление функций</h5>
            <ul>
              'no-func-assign': 'error',
              <li>Запрещено переопределение функций, созданных с помощью функционального объявления (function expression) <pre class="language-js"><code>- function myFunc() {};
- myFunc = 2;
</code></pre></li>

              <li>Запрещено объявление значений внутри блоков</li>

              <li>Новые функции не создаются с помощью конструктора <code>Function</code></li>

              <li>Вместо коллекции <code>arguments</code>, используется rest-оператор</li>

              <li>Вместо вызова функции через <code>apply</code> используется spread-оператор</li>
            </ul>

            <h5 id="">Создание значений</h5>
            <ul>
              <li>Не вызываются служебные конструкторы, создающие объекты из глобальной области видимости <code>Math(), JSON(), Reflect()</code>.</li>

              <li>При создании непустых массивов запрещено опускать пустые значения (ставить подряд несколько запятых)</li>

              <li>При создании непустых объектов и массивов не используются «висячие» запятые</li>

              <li>Не используются конструкторы примитивов, которые используются для автобоксинга <code>String</code>, <code>Number</code>, <code>Boolean</code></li>

              <li>Конструкторы вызываются со скобками, даже если у них нет параметров.</li>

              <li>Символы (<code>Symbol</code>) создаются вызовом функции <code>Symbol</code> без ключевого слова <code>new</code>.</li>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Хорошие практики</h4>
            <ul>
              <li>Не используется конструкция <code>with</code>.</li>

              <li>Не используются <code>alert</code>.</li>

              <li>Не используется выполнение кода через <code>eval</code>.</li>

              <li>Не используется неявный eval — в функциях, которые поддерживают передачу исполняемого кода как строку, например <code>setTimeout</code>.</li>

              <li>Не используется протокол javascript.</li>

              <li>Конструкторы не используются без ключевого слова <code>new</code>.</li>
            </ul>

            <h5>Манкипатчинг</h5>

            <ul>
              <li>Встроенные в язык объекты и прототипы не расширяются в рантайме</li>

              <li>Не переопределяются глобальные значения (<code>undefined</code>, <code>null</code>, <code>Object</code>, <code>window</code> и прочие)</li>
            </ul>

            <h5>Контекст</h5>
            <ul>
              <li>bind не используется вне методов классов</li>

              <li>в функциях, которые не являются методами никакого объекта или класса не используется <code>this</code></li>
            </ul>

            <h5>Переменные</h5>
            <ul>
              <li>Переменные, объявленные через <code>var</code> не удаляются оператором <code>delete</code></li>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Приведение типов</h4>
            <ul>
              <li>Не используется лишнее приведение к Boolean. Например, нет большого смысла переводить в boolean условия в конструкциях <code>if</code>, <code>while</code>, <code>for</code>, в первом операнде тернарного оператора</li>

              <li>Оператор <code>typeof</code> используется корректно — используются только правильные значения, возвращаемые оператором, не производится сравнения со строковыми литералами, которые содержат некорректные значения <code>typeof</code></li>

              <li>В <code>parseInt</code> обязательно передается второй параметр — основание системы счисления, даже в случае с десятичной системой счисления</li>
            </ul>

            <h5>Константы в условиях</h5>

            <ul>
              <li>В блоки условия операторов if, while, for и тернарного оператора не передается константное значение, которое подразумевает, что условие выполняется (или не выполняется) всегда <pre class="language-js"><code>- if (true) {}
+ if (a > 1) {}</code></pre>

              <pre class="language-js"><code>- var ternaryValue = true ? 'a' : 'b';
+ var ternaryValue = isA() ? 'a' : 'b';
              </code></pre></li>
            </ul>
          </div>
        </article>

      </section>

      <section class="chapter">
        <h2>Чистый код</h2>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Лишние символы (пробелы, точки с запятой и прочее)</h4>
            <ul>
              <li>Не используются лишние (множественные) точки с запятой</li>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Отладчик и консоль</h4>
            <ul>
              <li>В коде не используется оставленных выводов в консоль</li>

              <li>В коде нет забытых инструкций debugger</li>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Неиспользуемый код</h4>
            <ul>
              <li>
                В проекте нет недоступного кода, который никогда не выполнится<pre class="language-js"><code>- if (false) {
-   doSomething();
- }
+
+ if (needToDoSomething()) {
+   doSomething();
+ }</code></pre>
              </li>

              <li>В коде нет объявленных, но неиспользуемых переменных. Проверка не относится к параметрам функций.</li>

              <li>
                В коде нет выражений, значения которых не записываются в переменные, параметры функций, свойства объектов и не передаются как параметры функций <pre class="language-js"><code>- check === true && doSomething();
-
+ if (check) {
+   doSomething();
+ }</code></pre></li>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Обработка ошибок и исключения</h4>
            <ul>
              <li>
                Для выбрасывания исключения в оператор <code>throw</code> передаются только объекты Error. Передавать литералы запрещено.<pre class="language-js"><code>- throw 'Passed value is out of range';
+ throw new RangeError('Rassed value is out of range');</code></pre></li>
            </ul>

            <h5>try..catch с пустым try</h5>
            <ul>
              <li>В конструкции <code>try..catch</code> запрещен пустой блок <code>try</code></li>
            </ul>
          </div>
        </article>

      </section>

      <section class="chapter">
        <h2>Документирование</h2>

        <article class="chapter-part">
          <div class="chapter-part-col">
            При написании jsDoc используются следующие ограничения:

            <ul>
              <li>необязательно добавлять текстовое описание конструкциям @return и @param, достаточно просто указания типа и названия параметра для @param</li>

              <li>описание возвращаемного типа @return требуется только в том случае, если функция возвращает какое-то значение. Правило не действует для конструкторов, для них указывать @return необязательно. Также необязательно указывать тег @return для функций, в которых конструкуия <code>return</code> используется без возвращаемого значения для выхода из функции</li>

              <li>для описания возвращаемого значения из функции используется тег @return, а не @returns</li>
            </ul>
          </div>
        </article>

      </section>

      <section class="chapter">
        <h2>Прочее</h2>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <ul>
              <li>При итерировании по объектам через <code>for..in</code> при работе со свойствами используется конструкция <code>hasOwnProperty</code></li>

              <li>В функциях не используются обращения к <code>caller</code> и <code>callee</code></li>

              <li>В объектах напрямую не переопределяется свойство <code>__iterator__</code></li>

              <li>
                В объектах напрямую не переопределяется свойство <code>__proto__</code>. Разрешено переопределять <code>__proto__</code> через <code>Object.create</code> или запись в прототип, объектов, созданных другими конструкторами, но напрямую редактировать <code>__proto__</code> нельзя<pre class="language-js"><code>- var obj = {
-   __proto__: Parent
- };
+
+ var Obj = function() {};
+ Obj.prototype = new Parent();
+ var obj = new obj;
+
+ var obj = Object.create(Parent.prototype);</code></pre></li>

              <li>В коде не используются лейблы. Лейблы используются с конструкциями <code>break</code> и <code>continue</code> для направленного выхода из цикла и могут привести к слишком сложному для понимания коду</li>

              <li>Блоки, использующиеся в коде должны описывать тело функции, условия, оператора <code>switch</code> и прочие конструкции относящиеся к группировке множественных операций. Блоки не должны использваться сами по себе, любой блок должен быть частью другого выражения.</li>

              <li>
                В коде не используется оператор «запятая» для описания последовательностей действий. Для создания переменных используются отдельные ключевые слова <code>let</code>, <code>const</code>, <code>var</code>, в операторы группировки, условные операторы и прочие конструкции. Исключение составляет начальное условие оператора <code>for</code><pre class="language-js"><code>- const result = (1, 2); // 2
+ const result = 2;

- switch (val = getVal(), val) {}
+ val = getVal();
+ switch(val) {}

+ for (var i = 0, l = 100; i < l; i++);</code></pre></li>
            </ul>
          </div>
        </article>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <h4 id="">Регулярные выражения</h4>
            <ul>
              <li>В регулярных выражениях не используются «управляющие выражения»</li>

              <li>В регулярных выражениях не используются пустые классы символов <code>[]</code> (блоки, ограниченные квадратными скобками)</li>

              <li>В коде регулярные выражения не создаются через конструктор RegExp из строки, которая не может быть разобрана как правильное регулярное выражение</li>

              <li>
                В регулярных выражениях не используются нескольких последовательных пробелов. Вместо этого предлагается использовать модификаторы количества {3}
                <pre class="language-js"><code>- /   /.exec(myString);
+ /\s{3}/.exec(myString);</code></pre></li>
            </ul>
          </div>
        </article>

      </section>

      <section class="chapter">
        <h2>node.js</h2>

        <article class="chapter-part">
          <div class="chapter-part-col">
            <ul>
              <li>В node.js файлах не используется конструкция <code>process.exit</code>.</li>
            </ul>
          </div>
        </article>

      </section>

    </main>

    <footer>
      <div class="contacts">
        <a class="logo-full" href="https://htmlacademy.ru">
          <img src="img/logo-full.svg" width="161" height="55" alt="HTML Academy" title="HTML Academy">
        </a>
        <div class="social-icons">
          <a class="icon icon-vk" href="https://vk.com/htmlacademy" target="_blank">
            Вконтакте
          </a>
          <a class="icon icon-fb" href="https://www.facebook.com/htmlacademy" target="_blank">
            Facebook
          </a>
          <a class="icon icon-tw" href="https://twitter.com/htmlacademy_ru" target="_blank">
            Twitter
          </a>
          <a class="icon icon-ig" href="https://instagram.com/htmlacademy" target="_blank">
            Instagram
          </a>
        </div>
        <div class="github">
          <a class="github-link" href="https://github.com/htmlacademy" target="_blank">
            GitHub
          </a>
        </div>
      </div>
    </footer>

    <script src="js/prism.js"></script>
  </body>
</html>
