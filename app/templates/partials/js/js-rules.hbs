# Синтаксис и лексика
## Отступы, пробелы и переносы
Для правильного форматирования используйте файл .editorconfig в вашем редакторе.

'indent': ['error', 2, {
    SwitchCase: 1,
    // continuation indent
    VariableDeclarator: 2,
    MemberExpression: 2,
    FunctionDeclaration: {parameters: 2},
    FunctionExpression: {parameters: 2},
    CallExpression: {arguments: 2}
}],
- Для отступов используются два пробела. Знак табуляции не используется. При переносах в продолжении строки используется четыре пробела.

'no-irregular-whitespace': 'error', // eslint:recommended
- Запрещено одновременное использование табов и пробелов для отступов.

'no-unexpected-multiline': 'error', // eslint:recommended
- Выражения должны заканчиваться точками с запятой.

'no-multi-spaces': 'error',
- Внутри строки не используется более одного пробела.

'brace-style': 'error',
- Открывающие скобки блоков кода находятся на одной строке с оператором, которых их использует
```javascript
// Плохо:
if (condition)
{
  // code
}

// Хорошо
if (condition) {
  // code
}
```

'block-spacing': ['error', 'always'],
- В однострочных блоках кода, код отделен от открывающей и закрывающей скобки пробелом

'array-bracket-spacing': ['error', 'never'],
- В однострочных массивах скобки не отделяются пробелами, первое значение идет непосредственно после закрывающей скобки, а закрывающая скобка идет непосредственно после последнего значения массива

'comma-spacing': 'error',
- После запятой всегда должен ставиться пробел, если запятая не в конце строки

'comma-style': 'error',
- Запрещено переносить запятую на новую строку при создании множественных переменных через один var, при объявлении массивов и объектов. Запрещено использовать запятую в конце списков, объектов или наоборов параметров функции.

'eol-last': 'error',
- Файл должен заканчиваться пустой строкой

'no-trailing-spaces': 'error',
- Строка не должна заканчиваться пробелами

'object-curly-spacing': 'error',
- В однострочных объектах и при деструктуризации фигурные скобки отбиваются пробелами с двух сторон

'no-mixed-spaces-and-tabs': 'error', // eslint:recommended
- В коде не используются совместно табы и пробелы

'no-multiple-empty-lines': ['error', {max: 2}],
- Блоки кода отделяются друг от друга не более чем двумя пустыми строками

'linebreak-style': 'off', // check this in git
- В качестве символа строки используется стандартный символ, который используется в системе

'computed-property-spacing': 'error',
- При объявлении вычисляемых ключей в объектах с помощью синтаксиса ES2016 в квадратных скобках не используются пробелы

'func-call-spacing': 'error',
- Оператор вызова функции () не отделяется круглыми скобками от названия функции

'key-spacing': 'error',
- В объектах после объявления ключа не ставится пробел. После двоеточия, которое отделяет в объектах ключ от значения может стоять только один пробел, выравнивать несколько значений при объявлении многострочного объекта запрещено

'keyword-spacing': 'error',
- Ключевые слова отделяются пробелами. Правило касается всех блоков, которые не оговорены отдельно в других правилах. В частности ключевые слова должны отделяться пробелами для условных операторов, циклов, операторов множественного выбора, блоков try..catch, объявлений классов и т. д.

'padded-blocks': ['off', 'never'],
- В блоках кода первая и последняя строка не должны быть пустыми (код не отбивается от начала блока кода)

'semi-spacing': 'error',
- После двоеточий и точек с запятым ставятся пробелы. Перед ними — не ставятся.

'space-before-blocks': 'error',
- Перед скобками начинающими новый блок кода должен ставиться пробел.

'space-before-function-paren': ['error', {named: 'never', anonymous: 'always'}],
- при объявлении анонимных функций, скобки с параметрами ставятся непосредственно после ключевого слова function. Если функция именована, перед названием ставится пробел, после — нет.

'spaced-comment': ['error', 'always'],
- В комментариях текст отбивается пробелом от начала комментария.

'generator-star-spacing': ['error', 'after'],
- При создании генераторов, звездочка идет сразу после ключевого слова function без пробелов

'rest-spread-spacing': 'error',
- В spread-операторе точки не отделяются от названия коллекции

'yield-star-spacing': ['error', 'after']
- Звездочка после ключевого слова yield не отбивается пробелом. После звездочки проблел ставится всегда.

## Строки
'no-multi-str': 'error', // запрет на использование переносов в ES5-строках
- В строках, объявленных с помощью одинарных и двойных кавычек запрещено использовать переносы.

'no-octal-escape': 'error',
- В строках запрещено указывать код спецсимволов в восьмеричной системе счисления

```javascript
// Плохо
var foo = "Copyright \251";

// Хорошо
var foo = "Copyright \u00A9";   // unicode
```

'quote-props': ['error', 'consistent'],
- При создании объектов через литералы свойства должны объявляться в одинаковом стиле: или без кавычек или с ними.

'quotes': ['error', 'single', {allowTemplateLiterals: true}],
- В строках используются одинарные кавычки. Разрешено использовать строковые шаблоны. Если позволяет поддержка, предпочтение отдается строковым шаблонам.

## Числа
'no-floating-decimal': 'error', // запрет на опускание нуля
- В числах запрещено опускать ноль в дробной и целой части.

'no-octal': 'error', //default
- Запрещено использовать ведущий ноль при создании чисел, поскольку это приводит к созданию числа в восьмеричной системе счисления.

## Литералы
'no-array-constructor': 'error',
- Массивы должны создаваться через литерал массива, а не через конструктор. Допустимое исключение — создание массива определенной длины.

'no-new-object': 'error',
- Объекты должны создаваться через литерал объекта, а не через конструктор.

### Объекты
'no-dupe-keys': 'error',
- При создании объектов запрещено дублирование ключей.

'no-dupe-args': 'error',
- При описании функций запрещено дублировать названия параметров.

'no-duplicate-case': 'error',
- В операторе `switch` запрещено дублировать условия (case)

### Массивы

## Операторы
'space-infix-ops': 'error',
- В бинарных и тернарных операторах операнды и символы оператора отделяются пробелами.

'space-unary-ops': ['error', {words: true, nonwords: false}],
- Унарные операторы не отделяются от операнда пробелом. Исключения составляют операторы, состоящие из слов, а не символов, например оператор typeof.

# Именование
'no-label-var': 'error',
- Запрещено объявлять переменные, имена которых совпадают с именами используемых в коде лейблов

'camelcase': 'error',
- Все переменные должны быть названы в верблюжьем регистре. Исключения составляют константы которые должны именоваться прописными буквами в змеином регистре.

'no-shadow': 'error',
- Запрещено использовать имена переменных, которые используются во внешних областях видимости.

'no-shadow-restricted-names': 'error',
- Запрещено называть переменные и свойства ключевыми словами JSж

'no-undef': 'error', //default // нельзя использовать необъявленные переменные
- Запрещено использовать переменные, не объявленные ранее. При использовании переменной, объявленной в другом модуле в глобальной области видимости нужно обращаться к ней как в свойству объекта `window/global`.

'no-undef-init': 'error', // нельзя создавать переменные без значения
- Запрещено объявлять переменные без значения.

'no-undefined': 'error', // нельзя использовать значение undefined
- Запрещено напрямую обращаться к значению undefined.

'new-cap': 'error',
- С заглавной буквы называются только функции-конструкторы.


# Предотвращение ошибок
'semi': 'error',
- Все точки с запятой должны быть проставлены явно, не стоит рассчитывать на автоматическую расстановку точек с запятой ASI.

'unicode-bom': 'warn',
- Не рекомендуется использовать указатель Unicode BOM в коде, потому что код должен быть сохранен не в кодировке UTF-16, а в кодировке UTF-8, в которой нет указателя порядка бит.

'curly': ['error', "all"],
- Обязательно используются блоки кода даже если в выражении содержится одна строчка

'no-empty': 'error',
- В коде нет пустых блоков кода

'strict': ['error', 'global'],
- Код работает в строгом режиме: в начале всех файлов явно прописана директива `use strict`.

## Условные операторы
'yoda': ['error', "never"]
- Запрещена "проверка Йоды" — в условных операторах в блоке условия при сравнении переменной или свойства со значением сначала идет переменная или свойство объекта и только потом значения, а не наоброт.

```javascript
if (1 === myValue) {} // Плохо
if (myValue === 1) {} // Хорошо
```

'eqeqeq': 'error', // использование строгого сравнения
- При сравнении двух значений используется оператор строгого сравнения вместо оператора нестрогого сравнения

'no-cond-assign': 'error', // eslint:recommended // запрет на присвоение в блоке
- В условных операторах не используется оператор присвоения

'no-unsafe-negation': 'error', //
- В условтях не используется небезопасное отрицание, например использование ! в in или instanceof без скобок.

'use-isnan': 'error',
- Запрещено сравнение с NaN. Для проверки, является результат операции числовым, нужно использовать `isNaN`.

'no-fallthrough': 'error', // запрет на проваливание в switch
- Запрещено использовать case без break или return в блоках switch.

'no-nested-ternary': 'error',
- Не используются вложенные тернарные операторы.


## Функции
'consistent-return': 'error',
- Функция не возвращает undefined, особенно если есть другой return

'no-return-assign': 'error',
- В return не используется оператор присваивания.

'arrow-parens': ['error', 'always'],
- В стрелочных функциях всегда используются скобки для параметров, даже если параметр один

## Классы
'constructor-super': 'error', // eslint:recommended
- В конструкторе классов-наследников  обязательно вызывается super()

'no-this-before-super': 'error',  // eslint:recommended
- В конструкторе нет обращения к this до того, как будет вызван super()


## Объявление переменных и функций
'no-var': 'error',
- При объявлении переменных предпочтение отдается ключевым словам let и const. Переменные объявляются через var только при наличии проблем с поддержкой кода.

'no-redeclare': 'error', //default
- Запрещено переопределять с помощью ключевого слова ранее созданные переменные

'one-var': ['error', {
    var: 'never',
    let: 'never',
    const: 'never'
}],
- Запрещено использовать множественное объявление через одно ключевое слово. Для каждой переменной используется отдельный `var`, `let` или `const`.


### Объявление функций
'no-func-assign': 'error',
- Функции объявляются как функциональные выражения, а не определения функций.
```javascript
var myFunc = function() {}; // Хорошо
function myFunc() {}; // Плохо
```

'no-inner-declarations': ["error", "functions"],
- Запрещено объявление значений внутри блоков

'no-new-func': 'error',
- Новые функции не создаются с помощью конструктора `Function`

'prefer-rest-params': 'error',
- Вместо коллекции `arguments`, используется rest-оператор

'prefer-spread': 'error',
- Вместо вызова функции через `apply` используется spread-оператор

### Создание значений
'no-obj-calls': 'error',
- Не вызываются служебные конструкторы, создающие объекты из глобальной области видимости `Math(), JSON(), Reflect()`.

'no-sparse-arrays': 'error', // запрет на массивы с пропусками
- При создании непустых массивов запрещено опускать пустые значения (ставить подряд несколько запятых)

'comma-dangle': ['error', 'only-multiline']
- При создании непустых объектов и массивов не используются «висячие» запятые

'no-new-wrappers': 'error',
- Не используются конструкторы примитивов, которые используются для автобоксинга `String`, `Number`, `Boolean`

'new-parens': 'error',
- Конструкторы вызываются со скобками, даже если у них нет параметров.

'no-new-symbol': 'error',
- Символы (`Symbol`) создаются вызовом функции `Symbol` без ключевого слова `new`.

## Хорошие практики
'no-with': 'error',
- Не используется конструкция `with`.

'no-alert': 'error',
- Не используются `alert`.

'no-eval': 'error',
- Не используется выполнение кода через `eval`.

'no-implied-eval': 'error',
- Не используется неявный eval — в функциях, которые поддерживают передачу исполняемого кода как строку, например `setTimeout`.

'no-script-url': 'error',
- Не используется протокол javascript.

'no-new': 'error', // запрет на использование конструкторов для сайдэффектов
- Конструкторы не используются без ключевого слова `new`.

### Манкипатчинг
'no-extend-native': 'error',
- Встроенные в язык объекты и прототипы не расширяются в рантайме

'no-global-assign': 'error',
- Не переопределяются глобальные значения (undefined, null, Object, window и прочие)

### Контекст
'no-extra-bind': 'error',
- bind не используется вне методов классов

'no-invalid-this': 'error',
- в функциях, которые не являются методами никакого объекта или класса не используется `this`

### Переменные
'no-delete-var': 'error', //eslint:recommended
- Переменные, объявленные через `var` не удаляются оператором `delete`

## Приведение типов
'no-extra-boolean-cast': 'error',
- Не используется лишнее приведение к Boolean. Например, нет большого смысла переводить в boolean условия в конструкциях `if`, `while`, `for`, в первом операнде тернарного оператора

'valid-typeof': 'error',
- Оператор `typeof` используется корректно — используются только правильные значения, возвращаемые оператором, не производится сравнения со строковыми литералами, которые содержат некорректные значения `typeof`

'radix': 'error'
- В `parseInt` обязательно передается второй параметр — основание системы счисления, даже в случае с десятичной системой счисления

### Константы в условиях
'no-constant-condition': 'error'
- В блоки условия операторов if, while, for и тернарного оператора не передается константное значение, которое подразумевает, что условие выполняется (или не выполняется) всегда
```diff
- if (true) {}
+ if (a > 1) {}
```
```diff
- var ternaryValue = true ? 'a' : 'b';
+ var ternaryValue = isA() ? 'a' : 'b';
```

# Модульность и области видимости
## Глобальная область видимости
## Системы сборки

# Чистый код
## Лишние символы (пробелы, точки с запятой и прочее)
'no-extra-semi': 'error',
- Не используются лишние (множественные) точки с запятой

## Отладчик и консоль
'no-console': 'error',
- В коде не используется оставленных выводов в консоль

'no-debugger': 'error',
- В коде нет забытых инструкций debugger

## Неиспользуемый код
'no-unreachable': 'error',
- В проекте нет недоступного кода, который никогда не выполнится
```diff
- if (false) {
-   doSomething();
- }
+ if (needToDoSomething()) {
+   doSomething();
+ }
```

'no-unused-vars': ['error', {args: 'none'}]
- В коде нет объявленных, но неиспользуемых переменных. Проверка не относится к параметрам функций.

'no-unused-expressions': 'error',
- В коде нет выражений, значения которых не записываются в переменные, параметры функций, свойства объектов и не передаются как параметры функций
```diff
- check === true && doSomething();
+ if (check) {
+   doSomething();
+ }
```

## Обработка ошибок и исключения
'no-throw-literal': 'error',
- Для выбрасывания исключения в оператор `throw` передаются только объекты Error. Передавать литералы запрещено.
```diff
- throw 'Passed value is out of range';
+ throw new RangeError('Rassed value is out of range');
```

### try..catch с пустым try
'no-ex-assign': 'error'
- В конструкции `try..catch` запрещен пустой блок `try`

# Документирование
'valid-jsdoc': ['error', {
    requireParamDescription: false,
    requireReturnDescription: false,
    requireReturn: false,
    prefer: {returns: 'return'}
}],
При написании jsDoc используются следующие ограничения:
- необязательно добавлять текстовое описание конструкциям @return и @param, достаточно просто указания типа и названия параметра для @param
- описание возвращаемного типа @return требуется только в том случае, если функция возвращает какое-то значение. Правило не действует для конструкторов, для них указывать @return необязательно. Также необязательно указывать тег @return для функций, в которых конструкуия `return` используется без возвращаемого значения для выхода из функции
- для описания возвращаемого значения из функции используется тег @return, а не @returns

# Прочее
'guard-for-in': 'error'
- При итерировании по объектам через `for..in` при работе со свойствами используется конструкция `hasOwnProperty`

'no-caller': 'error',
- В функциях не используются обращения к `caller` и `callee`

'no-iterator': 'error',
- В объектах напрямую не переопределяется свойство `__iterator__`

'no-proto': 'error',
- В объектах напрямую не переопределяется свойство `__proto__`. Разрешено переопределять `__proto__` через `Object.create` или запись в прототип, объектов, созданных другими конструкторами, но напрямую редактировать `__proto__` нельзя
```diff
- var obj = {
-   __proto__: Parent
- };
+
+ var Obj = function() {};
+ Obj.prototype = new Parent();
+ var obj = new obj;
+
+ var obj = Object.create(Parent.prototype);
```

'no-labels': 'error',
- В коде не используются лейблы. Лейблы используются с конструкциями `break` и `continue` для направленного выхода из цикла и могут привести к слишком сложному для понимания коду

'no-lone-blocks': 'error',
- Блоки, использующиеся в коде должны описывать тело функции, условия, оператора `switch` и прочие конструкции относящиеся к группировке множественных операций. Блоки не должны использваться сами по себе, любой блок должен быть частью другого выражения.

'no-sequences': 'error',
- В коде не используется оператор «запятая» для описания последовательностей действий. Для создания переменных используются отдельные ключевые слова `let`, `const`, `var`, в операторы группировки, условные операторы и прочие конструкции. Исключение составляет начальное условие оператора `for`
```diff
- const result = (1, 2); // 2
+ const result = 2;

- switch (val = getVal(), val) {}
+ val = getVal();
+ switch(val) {}

+ for (var i = 0, l = 100; i < l; i++);
```

## Регулярные выражения
'no-control-regex': 'error',
- В регулярных выражениях не используются «управляющие выражения»

'no-empty-character-class': 'error',
- В регулярных выражениях не используются пустые классы символов `[]` (блоки, ограниченные квадратными скобками)

'no-invalid-regexp': 'error',
- В коде регулярные выражения не создаются через конструктор RegExp из строки, которая не может быть разобрана как правильное регулярное выражение

'no-regex-spaces': 'error',
- В регулярных выражениях не используются нескольких последовательных пробелов. Вместо этого предлагается использовать модификаторы количества {3}
```diff
- /   /.exec(myString);
+ /\s{3}/.exec(myString);
```

# node.js
'no-process-exit': 'error',
- В node.js файлах не используется конструкция `process.exit`.
